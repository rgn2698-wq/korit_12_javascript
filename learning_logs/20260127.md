# 쇼핑리스트

1. todolist를 shoppinglist로 개조.

- input 창에 가격추가

- js 부분을 수정해야됨. renderTodo() 부분에 html 태그가 추가 되어야함. span / div

- 지시사항
html 태그에 있는 todolist 기준의 BEM을 전부 shoppinglist 기준 BEM으로 수정할 것

# Fetch API
## 정의
- 네트워크 통신을 포함한 리소스 취득을 위한 인터페이스가 정의되어있는 몽,ㅁ.
- resource : DB에 저장되어있는 값들을 의미
- CURD
  1. C : Create 데이터 생성
  2. R : Read DB에 저장되어있는 데이터를 읽어 오는덕
  3. U : Update 데이터 수정
  4. D : Delete 데이터 삭제

- localStorage에 todo / shopping item을 추가하고 읽어오고 삭제까지 해봄

이번 수업때는 jsonplaceholder를 활용하여 CRUD를 구현해볼것 -> Fetch API를 학습

https://jsonplaceholder.typicode.com/0
를 기준으로
1. /posts
2. /comments
3. /albums
4. /photos
5. /users
6. /todos
등을 통해 임의의 구현되어있는 JSON데이터를 활용하여 프론트엔드의 표현하는것이 가능.

## Promise

자료형의 일종으로

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>01_fetchapi.html</title>
</head>
<body bgcolor="777777">
  <script>
    // 형식에 주목
    // Get / Read : 읽어오기 / id가 1인 데이터 조회
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())
      .then(json => console.log(json.body)) 
      
    // Post / Create : 데이터 생성
    fetch('https://jsonplaceholder.typicode.com/posts', {
      method: 'POST', // http request 요청 방법
      body: JSON.stringify({
        title: 'foo',
        body: 'bar',
        userId: 1,
      }),
      headers: {
        'Content-type': 'application/json; charset=UTF-8',
      },
    })
    .then((response) => response.json())
    .then((json) => {
    console.log(json)
    })

    // put / Update : 데이터 수정
    fetch('https://jsonplaceholder.typicode.com/posts/1', {
      method: 'PUT',
      body: JSON.stringify({
        id: 1,
        title: '이거 다음에는 Promise 타입 학습',
        body: '그거 하면 아마도 자습시간',
        userId: 1,
      }),
      headers: {
        'Content-type': 'application/json; charset=UTF-8',
      },
    })
    .then((response) => response.json())
    .then((json) => {
      console.log(json)
    })

    // Delete : 데이터 삭제
    fetch('https://jsonplaceholder.typicode.com/posts/1', {
      method: 'DELETE',
    })
    // 삭제됬는지 확인할수없기 때문에 read를 따로 해야됨.
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())
      .then(json => console.log(json.body)) 
    // 삭제후에는 todolist 기준으로 renderTodo를 새로해야함
    // C / U / D => 새로 R을 해야함.
  </script>
</body>
</html>
```

- 추후 axios 라이브러리 도입하게 되면 좀 더 간단하게 코드를 작성할수 있음.
# Promise & Async/Await
## Promise
- JS상에서 `비동기처리`에 사용되는 `객체` 
  - 특정코드의 실행이 완료 될때까지 기다리지않고 다음코드를 실행할 수 있도록 하는 방식.
- 원래 웹은 요청에 대한 반응이 _순차적으로 이루어지고_, 먼저 실행된 코드가 완료되어야 다음코드를 실행하는 순서를 가지고있음.
  - 하지만 개선 이후에 요청을 보낸 후 요청에 대한 응답이 들어오는것과 관계없이 다음코드를 실행 시킬수있음.

- promise는 JS에서 브라우저에 제공하는 비동기 함수는 Web APIs 를 실행할때 실행한 코드가 완료될떄까지 기다리지않고 바로 다음 코드를 실행할수 있도록 해줌.
  - 비동기 함수의 실행이 완료되면 .then()함수를 통해 그 결과에 대한 코드를 실행할수 있게 해줌.

## Async / Await
- Promise와 동일한 목적으로 사용.
  - Async 비동기 실행을 의미하고, Await은 비동기 코드를 실행하는데 결과가 올때까지 기다렸다가 쓴다는 의미
  - 각각의 fetch()와 .then()에 매칭됨.

02_asyncawait.js

```js
// 02_asyncawait.js

// fetch() / async의 코드상 비교관련
function myfunc() {
  fetch(`https://jsonplaceholder.typicode.com/posts/1`)
    .then((response) => response.json())
    .then((json) => {console.log(json);})
    };

myfunc();
// 이상의 예시는 Get요청을 해서 서버로부터 응답이 오면 콘솔에 찍는 함수

/**
 * 그런데 서버로 요청을 보내고 응답을 보낸 후에 응답받은 결과를 바탕으로 다시 서버로 요청을 보낸다고 가정했을때는
 */

function myfunc2() {
  fetch(`https://jsonplaceholder.typicode.com/posts/1`)
  .then((response) => response.json())
  .then((json) => {
    console.log(json);
    fetch(`https://jsonplaceholder.typicode.com/posts/1`, {
      method: "PUT",
      body: JSON.stringify({
        id : 1,
        title : '이제슬슬 무슨말인지 모르겠다',
        body : '내가 뭘하고 있는거지',
        userId : 1,
      }),
      headers: {
        'Content-type': 'application/json; charset=UTF-8',
      },
    })
    .then((response) => response.json())
    .then((json) => {console.log(json);})
  })
};

myfunc2();
// 위의 예시는 Get요청을 해서 서버로부터 응답이 오면 콘솔에 찍고, 그 응답을 바탕으로 PUT요청을 다시 보내는 함수
// 그런데 이렇게 then()이 중첩되면 코드가 점점 복잡해지고 가독성이 떨어진다.
// 그래서 async/await 문법을 사용하면 더 깔끔하게 작성할 수 있다.

async function myfunc3() {
  const res1 = await fetch(`https://jsonplaceholder.typicode.com/posts/2`);
  const res1json = await res1.json();
  console.log(res1json);
  // 이상은 GET요청. async/await문법으로 작성한 것
  // async / await문법은 동기적으로 작성한 것처럼 보이지만 비동기적으로 작동한다.

  const res2 = await fetch(`https://jsonplaceholder.typicode.com/posts/2`, {
    method: "PUT",
    body: JSON.stringify({
      id: 2,
      title: '아 공부하기 싫다',
      body: '진짜 공부하기 싫다',
      userId: 1,
    }),
    headers: {
      'Content-type': 'application/json; charset=UTF-8',
    },
  });
  const res2json = await res2.json();
  console.log(res2json);
}

myfunc3();
```
# DOM 이벤트
- DOM(Document Object Model) -> document.write()
- 웹 페이지를 이용하면 웹 화면과 사용자 사이에서 많은 상호작용이 있음.
  - 버튼 클릭, 마우스 스크롤. 검색키워드를 입력하는 등의 행동
- 사용자가 웹 페이지를 이용하면서 행하는 행위를 event라고 함.

1. click 이벤트 : onclick
  - 사용자가 웹 페이지 내에서 마우스 왼쪽 버튼 클릭을 할때 발생하는 이벤트
    - 웹 화면에서 일어나는 모든 클릭이벤트를 감시할 필요는 없지만 `검색`, `저장` 처럼 사용자가 클릭을 하고 나면 연관된 기능을 처리해야하는 이벤트에 대해서는 JS에서 함수를 정의하여 확인해야함.
  - button 태그 요소에 클릭이벤트가 일어나는지를 감시하고 클릭이벤트가 일어나는 순간 특정 함수를 실행시키려면 button태그에 onclick속성을 사용해서 처리할수있음
    - button 태그에 id값을 넣고 거기에서 클릭이벤트를 addEventlistner() 통해서 처리)

ch11_events -> 01_event.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>01_event.html</title>
</head>
<body bgcolor="777777">
  <button onclick="myfuntion();">클릭!</button>
  <button id="btn1">클릭!</button>
  <button id="btn2">클릭!</button>
  <button id="btn3">클릭!</button>
  <script>
    function myfuntion1() {
      alert('버튼이 클릭되었습니다!');
    }
    function myfuntion2() {
      alert('이벤트 리스너 사용');
    }
    document.getElementById('btn1').addEventListener('click', myfuntion2);
    document.getElementById('btn2').addEventListener('click', function() {
      console.log('콜백 함수 실행')
    });
    document.getElementById('btn3').addEventListener('click', () => {
      console.log('화살표 함수 실행')
    });
  </script>
</body>
</html>
```

2. change 이벤트 : onchange
- 값이 변경되었을때 발생하는 이벤트
  - 대표적으로 change 이벤트가 발생하는 DOM요소는 `<select>`, `<input type="checkbox">`, `<input type="radio">`
- select
  - 여러개의 옵션에서 하나 이상의 옵션을 선택할때 사용되는 DOM요소로 사용자가 옵션을 바꿀때마다 웹에서는 change이벤트가 발생하고 JS에서 이 이벤트를 감시하며 특정함수를 실행하는 방식을 택함

  02_onchange.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="777777">
  <select id="sel1" onchange="dochange();">
    <option value="KR">한국</option>
    <option value="CN">중국</option>
    <option value="JP">일본</option>
  </select>
  <script>
    function dochange() {
      let selVal = document.getElementById('sel1').value;
      console.log(selVal);
    }
  </script>

</body>
</html>
```

3. key 이벤트(onketdown, onkeypress, onkeyup)
- key 이벤트는 사용자가 입력창에서 키보드를 입력할때 발생
  - 사용자가 키를 입력하면 keydown, keypress, keyup순으로 이벤트가 발생

03_keyevent.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="777777">
  <input 
  type="text"
  onkeypress="myfunc(event)"
  onkeydown="myfunc(event)"
  onkeyup="myfunc(event)"
  >
  <script>
    function myfunc(event) {
      console.log(event.type);    // 이벤트 이름 출력
      // console.log(event.target);  // 이벤트가 발생한 요소
      console.log(event.target.value);  // 이벤트 입력 시점에
    }
  </script>
</body>
</html>
```
이상의 코드에서 input type text라면 e.target.value는 꼭 기억할것
input 창에서 입력칸은 데이터가 DB에 있는 id와 일치하는지, 비밀번호와 일치하는지 체크하게 됨.